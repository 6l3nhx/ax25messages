import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';

// --- AX.25 Core Implementation START ---

/**
 * AX.25 v2.2 Core Implementation in TypeScript - Full-Featured Version
 *
 * This version adds:
 * - UI Frame (Connectionless) sending and receiving logic.
 * - SREJ (Selective Reject) sending and handling for efficient retransmissions.
 * - XID (Exchange Identification) parameter generation and parsing.
 * - Repeater (Digipeater) functionality to retransmit frames.
 * - Layer 3 Protocol ID (PID) integration for sending and receiving.
 *
 * Improvements implemented:
 * - FRMR (Frame Reject) sending and basic handling.
 * - T2 (Response Delay) and T3 (Inactivity) Timers.
 * - RNR (Receiver Not Ready) and RR (Receiver Ready) for Flow Control.
 * - More robust XID Parameter Handling (simplified byte-level encoding).
 * - Configurable Parameters for the link.
 * - Enhanced Callbacks for finer-grained event reporting.
 * - Basic Duplicate I-Frame Detection.
 * - Improved structured Error Reporting.
 * - P/F (Poll/Final) Bit Logic in Supervisory frames.
 */

// --- Constants ---
const FLAG_BYTE = 0x7E;
const PID_NO_LAYER_3 = 0xF0; // Common PID for no Layer 3 protocol (e.g., UI frames for text, APRS)

// Control Field Constants
const CONTROL_I = 0x00; // Information frame (LSB is 00)
const CONTROL_S = 0x01; // Supervisory frame (LSB is 01)
const CONTROL_U = 0x03; // Unnumbered frame (LSB is 11)

// Supervisory Frame Types (bits 2,3 of control field when S-frame)
// These constants define the SS bits (bits 2 and 3) AND the fixed 01 pattern (bits 0 and 1)
// Correct values based on AX.25 v2.2 S-frame control field:
// S S | 0 1
// 0 0 | 0 1 = 0x01 (RR)
// 0 1 | 0 1 = 0x05 (RNR)
// 1 0 | 0 1 = 0x09 (REJ)
// 1 1 | 0 1 = 0x0D (SREJ)
const CONTROL_RR = 0x01; // Receive Ready
const CONTROL_RNR = 0x05; // Receiver Not Ready
const CONTROL_REJ = 0x09; // Reject (Go-back-N)
const CONTROL_SREJ = 0x0D; // Selective Reject

// Unnumbered Frame Types (bits 2,3,4,6,7 of control field when U-frame)
const CONTROL_SABM = 0x2F; // Set Asynchronous Balanced Mode (Command)
const CONTROL_SABME = 0x6F; // Set Asynchronous Balanced Mode Extended (Command)
const CONTROL_DISC = 0x43; // Disconnect (Command)
const CONTROL_UA = 0x63; // Unnumbered Acknowledgment (Response)
const CONTROL_DM = 0x87; // Disconnected Mode (Response)
// Note: FRMR (Frame Reject) also uses 0x87, but is distinguished by the presence of an Info field.
const CONTROL_XID = 0xAF; // Exchange Identification (Command/Response)
const CONTROL_TEST = 0xE3; // Test (Command/Response) - Added this missing constant
const CONTROL_UI = 0x03; // Unnumbered Information (Command/Response) - Note: This is the same as U-frame, distinguished by P/F bit usually 0.

// --- Utility Functions (unchanged, but important for context) ---

/**
 * Converts a string callsign (e.g., "M0ABC-7") into its 7-byte AX.25 address field format.
 * - Pads with spaces (0x20) to 6 characters.
 * - Shifts bits for character encoding (left shift 1 bit).
 * - Adds SSID (Secondary Station ID) to the last byte.
 * - Sets the H (Has been digipeated) bit for digipeaters if applicable.
 * - Sets the E (End of Address) bit on the last byte of the address chain.
 *
 * @param callsign The callsign string (e.g., "M0ABC-7").
 * @param isLastAddress True if this is the last address in the address chain (sets E bit).
 * @param isCommand True if this is a command frame (sets C/R bit).
 * @param isDigipeater True if this address is for a digipeater.
 * @param hasBeenDigipeated True if this digipeater has already processed the frame (sets H bit).
 * @returns A Uint8Array representing the 7-byte AX.25 address field.
 */
function encodeCallsign(
    callsign: string,
    isLastAddress: boolean,
    isCommand: boolean,
    isDigipeater: boolean = false,
    hasBeenDigipeated: boolean = false
): Uint8Array {
    const parts = callsign.split('-');
    let baseCallsign = parts[0].toUpperCase();
    let ssid = parts.length > 1 ? parseInt(parts[1], 10) : 0;

    if (ssid < 0 || ssid > 15) {
        throw new Error("SSID must be between 0 and 15.");
    }
    if (baseCallsign.length > 6) {
        // AX.25 v2.2 technically supports 7-char callsigns for source/destination,
        // but many implementations are limited to 6. Enforcing 6 for compatibility.
        console.warn(`Callsign "${baseCallsign}" is longer than 6 characters. Truncating.`);
        baseCallsign = baseCallsign.substring(0, 6);
    }

    const addressBytes = new Uint8Array(7);

    // Encode callsign characters (6 bytes)
    for (let i = 0; i < 6; i++) {
        const charCode = baseCallsign.charCodeAt(i) || 0x20; // Pad with spaces (0x20)
        addressBytes[i] = charCode << 1; // Left shift 1 bit as per AX.25 spec
    }

    // Encode SSID and C/R/H/E bits in the 7th byte
    // Bit layout: [E][H/C/R][Reserved][SSID_MSB][SSID_LSB][Reserved_low_bits]
    // AX.25 v2.2 specifies reserved bits as 1 for some positions, 0 for others.
    // For digipeaters: H (Has been digipeated) bit (bit 7, C/R position)
    // For source/destination: C/R (Command/Response) bit (bit 7)
    // E (End of Address) bit (bit 8, MSB of last byte)

    let lastByte = (ssid << 1); // SSID (bits 1-4)
    lastByte |= (1 << 5); // Reserved bit (bit 5), always 1

    if (isDigipeater) {
        if (hasBeenDigipeated) {
            lastByte |= (1 << 7); // H bit (bit 7, in C/R position for digipeaters)
        }
    } else {
        if (isCommand) {
            lastByte |= (0 << 7); // C bit (bit 7, 0 for command)
        } else {
            lastByte |= (1 << 7); // R bit (bit 7, 1 for response)
        }
    }

    if (isLastAddress) {
        lastByte |= 0x01; // E bit (Least Significant Bit of the 7th byte)
    }

    addressBytes[6] = lastByte;

    return addressBytes;
}

/**
 * Decodes a 6-byte AX.25 callsign format back to a string.
 */
function decodeCallsign(bytes: Uint8Array): string {
    let callsign = '';
    for (let i = 0; i < 6; i++) {
        callsign += String.fromCharCode(bytes[i] >>> 1); // Shift right by 1 bit
    }
    return callsign.trim();
}

/**
 * Calculates the FCS (Frame Check Sequence) using CRC-CCITT (X.25) polynomial.
 * @param bytes The data over which to calculate the FCS.
 * @returns The 16-bit FCS value.
 */
function calculateFCS(bytes: Uint8Array): number {
    let fcs = 0xFFFF; // Initial value
    const polynomial = 0x8408; // X^16 + X^12 + X^5 + 1 (reversed)

    for (const byte of bytes) {
        fcs ^= byte;
        for (let i = 0; i < 8; i++) {
            if (fcs & 0x0001) {
                fcs = (fcs >>> 1) ^ polynomial;
            } else {
                fcs >>>= 1;
            }
        }
    }
    return fcs ^ 0xFFFF; // Final XOR
}

/**
 * Performs bit stuffing on a byte array to prevent accidental flag sequences (0x7E).
 */
function bitStuff(data: Uint8Array): Uint8Array {
    let stuffedBits: number[] = [];
    let consecutiveOnes = 0;

    for (const byte of data) {
        for (let i = 0; i < 8; i++) {
            const bit = (byte >> i) & 0x01; // Process LSB first

            stuffedBits.push(bit);

            if (bit === 1) {
                consecutiveOnes++;
                if (consecutiveOnes === 5) {
                    stuffedBits.push(0); // Insert a zero bit
                    consecutiveOnes = 0;
                }
            } else {
                consecutiveOnes = 0;
            }
        }
    }

    // Convert bit array back to byte array
    const stuffedBytes = new Uint8Array(Math.ceil(stuffedBits.length / 8));
    for (let i = 0; i < stuffedBits.length; i++) {
        const byteIndex = Math.floor(i / 8);
        const bitPosition = i % 8;
        if (stuffedBits[i] === 1) {
            stuffedBytes[byteIndex] |= (1 << bitPosition);
        }
    }
    return stuffedBytes;
}

/**
 * Removes bit stuffing from a byte array.
 */
function bitUnstuff(data: Uint8Array): Uint8Array {
    let unstuffedBits: number[] = [];
    let consecutiveOnes = 0;

    for (const byte of data) {
        for (let i = 0; i < 8; i++) {
            const bit = (byte >> i) & 0x01; // Process LSB first

            if (bit === 1) {
                consecutiveOnes++;
                unstuffedBits.push(bit);
            } else {
                if (consecutiveOnes === 5) {
                    // This 0 was stuffed, skip it
                } else {
                    unstuffedBits.push(bit);
                }
                consecutiveOnes = 0;
            }
        }
    }

    const unstuffedBytes = new Uint8Array(Math.floor(unstuffedBits.length / 8));
    for (let i = 0; i < unstuffedBytes.length; i++) {
        for (let j = 0; j < 8; j++) {
            const bitIndex = i * 8 + j;
            if (bitIndex < unstuffedBits.length && unstuffedBits[bitIndex] === 1) {
                unstuffedBytes[i] |= (1 << j);
            }
        }
    }
    return unstuffedBytes;
}

// --- Interfaces ---
interface AX25Address {
    callsign: string;
    ssid: number;
    // Command/Response bit: true for Command, false for Response.
    // Last byte of address field (destination) sets C/R for the frame.
    // Source address last byte sets C/R for that address.
    crBit?: boolean;
    // Has Been Digipeated bit: true if this repeater has already handled it.
    hasBeenDigipeated?: boolean;
}

interface AX25Frame {
    source: AX25Address;
    destination: AX25Address;
    repeaters: AX25Address[]; // Array of repeater addresses
    control: Uint8Array;      // 1 or 2 bytes
    pid: number | null;       // 1 byte, if present
    info: Uint8Array | null;  // Variable length data
    isValidFCS: boolean;
    p_f_bit: boolean;         // Poll/Final bit
    isCommand: boolean;       // True if this frame is a Command (C/R bit on Destination)
    isExtended: boolean;      // True if extended (V2.2, 7-bit N(S)/N(R))
}

interface XIDParameters {
    // These are simplified for simulation. Real XID involves bit-packed TLV.
    supportedFrames: ('I' | 'UI' | 'SREJ' | 'REJ' | 'RR' | 'RNR')[];
    maxIFieldLength: number;
    windowSize: number; // K value
    extendedSequencing: boolean;
}

interface QueuedIFrame {
    ns: number;
    frameBytes: Uint8Array; // Stored raw bytes for retransmission
    retries: number;
    sentTime: number;
    acknowledged: boolean; // For SREJ, indicates if this specific frame was ACKed
}

interface AX25Error {
    type: 'FCS_MISMATCH' | 'PROTOCOL_ERROR' | 'TIMEOUT' | 'BUFFER_FULL' | 'DISCONNECTED' | 'INVALID_FRAME';
    message: string;
    frame?: AX25Frame; // The frame that caused the error, if applicable
}

// --- Logger Utility ---
class Logger {
    private static instance: Logger;
    private logLevel: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR';

    private constructor(level: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR' = 'INFO') {
        this.logLevel = level;
    }

    public static getInstance(level?: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR'): Logger {
        if (!Logger.instance) {
            Logger.instance = new Logger(level);
        } else if (level) {
            Logger.instance.logLevel = level; // Allow changing log level dynamically
        }
        return Logger.instance;
    }

    private shouldLog(level: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR'): boolean {
        const levels = { 'DEBUG': 0, 'INFO': 1, 'WARN': 2, 'ERROR': 3 };
        return levels[level] >= levels[this.logLevel];
    }

    public debug(message: string, ...args: any[]): void {
        if (this.shouldLog('DEBUG')) console.debug(`[DEBUG] ${new Date().toISOString()} - ${message}`, ...args);
    }

    public info(message: string, ...args: any[]): void {
        if (this.shouldLog('INFO')) console.info(`[INFO] ${new Date().toISOString()} - ${message}`, ...args);
    }

    public warn(message: string, ...args: any[]): void {
        if (this.shouldLog('WARN')) console.warn(`[WARN] ${new Date().toISOString()} - ${message}`, ...args);
    }

    public error(message: string, ...args: any[]): void {
        if (this.shouldLog('ERROR')) console.error(`[ERROR] ${new Date().toISOString()} - ${message}`, ...args);
    }
}

const logger = Logger.getInstance('DEBUG'); // Default to DEBUG for development

// --- AX.25 Encoder and Decoder (Simplified/Stubbed for this example) ---

class AX25Encoder {
    public encodeFrame(
        destination: string,
        source: string,
        repeaters: string[],
        control: Uint8Array,
        pid: number | null,
        info: Uint8Array | null,
        isCommand: boolean,
        p_f_bit: boolean,
        localCallsign: string // Needed for C/R bit logic
    ): Uint8Array {
        let addressFields: Uint8Array[] = [];

        // Destination Address
        // isLastAddress is false because source or repeaters will follow
        addressFields.push(encodeCallsign(destination, false, isCommand, false, false));

        // Source Address
        // isLastAddress depends on whether there are any repeaters
        addressFields.push(encodeCallsign(source, repeaters.length === 0, isCommand, false, false));

        // Repeater Addresses
        repeaters.forEach((repeater, index) => {
            const isLastRepeater = (index === repeaters.length - 1);
            // Digipeaters are commands during transmission, and H-bit is set by the digipeater itself when repeating.
            // For the sender, H-bit is usually 0 unless it's explicitly marking a path.
            addressFields.push(encodeCallsign(repeater, isLastRepeater, true, true, false)); // isDigipeater=true, hasBeenDigipeated=false
        });

        // Combine all address fields into a single array of numbers
        let addressBytes: number[] = [];
        addressFields.forEach(addr => addressBytes.push(...Array.from(addr)));

        // Correct E-bit for source if repeaters were added after it.
        // If there are repeaters, the source address's E-bit must be cleared.
        if (repeaters.length > 0) {
            // The source address is the second one in addressFields (index 1).
            // Its 7th byte (index 6 within its 7 bytes block) needs its LSB (E-bit) cleared.
            // The source address block starts at index 7 in the combined addressBytes array.
            // So, the byte to modify is addressBytes[7 + 6] = addressBytes[13].
            addressBytes[13] &= ~0x01; // Clear LSB (E bit)
        }


        // Control Field
        let controlBytes = Array.from(control);
        if (p_f_bit) {
            // Set P/F bit
            if (controlBytes.length === 1) { // U-frame
                controlBytes[0] |= 0x10; // Bit 4
            } else if ((controlBytes[0] & 0x01) === CONTROL_I) { // I-frame
                controlBytes[1] |= 0x01; // Bit 0 of second byte
            } else if ((controlBytes[0] & 0x03) === CONTROL_S) { // S-frame
                controlBytes[0] |= 0x10; // Bit 4 of first control byte
            }
        } else {
            // Clear P/F bit
            if (controlBytes.length === 1) { // U-frame
                controlBytes[0] &= ~0x10;
            } else if ((controlBytes[0] & 0x01) === CONTROL_I) { // I-frame
                controlBytes[1] &= ~0x01;
            } else if ((controlBytes[0] & 0x03) === CONTROL_S) { // S-frame
                controlBytes[0] &= ~0x10;
            }
        }


        // PID Field (if present)
        let pidBytes: number[] = [];
        // PID is present in I-frames, UI frames, XID, TEST, FRMR
        const frameTypeIndicator = control[0] & 0x03;
        const controlByteWithoutPF = control[0] & 0xEF; // Mask P/F for U-frame comparison

        if (frameTypeIndicator === CONTROL_I ||
            controlByteWithoutPF === CONTROL_UI ||
            controlByteWithoutPF === CONTROL_XID ||
            controlByteWithoutPF === CONTROL_TEST ||
            controlByteWithoutPF === CONTROL_DM) { // Changed from CONTROL_FRMR to CONTROL_DM for consistency
            if (pid !== null) {
                pidBytes.push(pid);
            } else {
                // Default PID if not provided for these frame types
                pidBytes.push(PID_NO_LAYER_3);
            }
        }


        // Information Field (if present)
        const infoBytes = info ? Array.from(info) : [];

        // Combine all parts for FCS calculation
        const frameBody = new Uint8Array([
            ...addressBytes,
            ...controlBytes,
            ...pidBytes,
            ...infoBytes
        ]);

        const fcs = calculateFCS(frameBody);
        const fcsBytes = new Uint8Array([(fcs & 0xFF), (fcs >>> 8)]); // LSB first

        // Assemble the raw frame bytes (excluding flags)
        const rawFrame = new Uint8Array([
            ...frameBody,
            fcsBytes[0], // FCS LSB
            fcsBytes[1]  // FCS MSB
        ]);

        // Apply bit stuffing and add flags
        const stuffedFrame = bitStuff(rawFrame);
        return new Uint8Array([FLAG_BYTE, ...stuffedFrame, FLAG_BYTE]);
    }
}

class AX25Decoder {
    private buffer: Uint8Array = new Uint8Array(0);

    public processRawData(rawData: Uint8Array): AX25Frame[] {
        const frames: AX25Frame[] = [];
        this.buffer = new Uint8Array([...this.buffer, ...rawData]);

        let startIndex = -1;
        let endIndex = -1;

        while ((startIndex = this.buffer.indexOf(FLAG_BYTE)) !== -1) {
            endIndex = this.buffer.indexOf(FLAG_BYTE, startIndex + 1);

            if (endIndex !== -1) {
                const rawFrameSegment = this.buffer.slice(startIndex + 1, endIndex);
                this.buffer = this.buffer.slice(endIndex + 1); // Consume the processed frame

                try {
                    const unstuffed = bitUnstuff(rawFrameSegment);
                    const decodedFrame = this.decodeFrame(unstuffed); // This is where the error is thrown
                    frames.push(decodedFrame);
                } catch (e) {
                    logger.error(`Error decoding frame: ${e instanceof Error ? e.message : String(e)}`);
                }
            } else {
                break; // Awaiting the end flag
            }
        }
        return frames;
    }

    private decodeFrame(unstuffedBytes: Uint8Array): AX25Frame {
        logger.debug(`[Decoder] Decoding frame. Unstuffed bytes length: ${unstuffedBytes.length}, bytes: [${Array.from(unstuffedBytes).map(b => b.toString(16).padStart(2, '0')).join(', ')}]`);

        // Minimum frame size: 2 addresses (14 bytes) + 1 control byte + 2 FCS bytes = 17 bytes
        if (unstuffedBytes.length < 17) {
            throw new Error("Frame too short for AX.25 header.");
        }

        let offset = 0;

        // --- Address Fields ---
        const allAddresses: AX25Address[] = [];
        let isLastAddressFound = false;

        while (offset + 7 <= unstuffedBytes.length) {
            const addrBytes = unstuffedBytes.slice(offset, offset + 7);
            const callsignBytes = addrBytes.slice(0, 6);
            const ssidByte = addrBytes[6];

            let callsign = '';
            for (let i = 0; i < 6; i++) {
                callsign += String.fromCharCode(callsignBytes[i] >>> 1);
            }
            callsign = callsign.trim();

            const ssid = (ssidByte >>> 1) & 0x0F;
            const isEndAddress = (ssidByte & 0x01) === 0x01; // E-bit is LSB
            const crHBit = (ssidByte & 0x80) === 0x80; // C/R or H bit is MSB

            const address: AX25Address = {
                callsign: `${callsign}-${ssid}`,
                ssid: ssid,
            };

            if (allAddresses.length === 0) { // Destination
                address.crBit = !crHBit;
            } else if (allAddresses.length === 1) { // Source
                address.crBit = !crHBit;
            } else { // Repeater
                address.hasBeenDigipeated = crHBit;
            }

            allAddresses.push(address);
            offset += 7;

            logger.debug(`[Decoder] Parsed address: ${address.callsign}, SSID: ${ssid}, E-bit: ${isEndAddress ? 'SET' : 'CLEARED'}, C/R/H-bit: ${crHBit ? 'SET' : 'CLEARED'}, Current offset: ${offset}`);


            if (isEndAddress) {
                isLastAddressFound = true;
                break;
            }
        }

        if (allAddresses.length < 2 || !isLastAddressFound) {
            throw new Error("Invalid AX.25 frame: Missing destination/source address or E-bit not found.");
        }

        const destination = allAddresses[0];
        const source = allAddresses[1];
        const repeaters = allAddresses.slice(2);

        const isCommandFrame = destination.crBit !== undefined ? destination.crBit : true;

        // --- Control Field ---
        logger.debug(`[Decoder] Before control field parse. Offset: ${offset}. Remaining bytes: ${unstuffedBytes.length - offset}. Next byte: 0x${unstuffedBytes[offset]?.toString(16).padStart(2, '0') || 'N/A'}`);
        const controlFieldByte1 = unstuffedBytes[offset];
        let controlField: Uint8Array;
        let p_f_bit: boolean;
        let isExtended = false;

        // Check LSB (bit 0) to distinguish I-frames from S/U frames
        const lsbBit0 = controlFieldByte1 & 0x01;

        if (lsbBit0 === 0x00) { // I-frame (LSB is 0)
            // I-frames are always 2 bytes in Modulo 128 (AX.25 v2.2 with 7-bit sequencing)
            if (unstuffedBytes.length - offset < 2) {
                throw new Error("I-frame too short for 2 control bytes.");
            }
            controlField = unstuffedBytes.slice(offset, offset + 2);
            offset += 2;
            p_f_bit = ((controlField[1] & 0x01) === 0x01); // P/F is LSB of second control byte
            isExtended = true; // I-frames imply extended sequencing
            logger.debug(`[Decoder] Identified as I-frame. Control: 0x${controlField[0].toString(16)} 0x${controlField[1].toString(16)}`);
        } else { // S-frame or U-frame (LSB is 1)
            const lsbBit1 = (controlFieldByte1 >> 1) & 0x01; // Check bit 1

            if (lsbBit1 === 0x00) { // S-frame (LSB is 01)
                // S-frames are always 2 bytes in Modulo 128
                if (unstuffedBytes.length - offset < 2) {
                    throw new Error("S-frame too short for 2 control bytes.");
                }
                controlField = unstuffedBytes.slice(offset, offset + 2);
                offset += 2;
                p_f_bit = ((controlField[0] & 0x10) === 0x10); // P/F is bit 4 of first control byte
                isExtended = true; // S-frames imply extended sequencing
                logger.debug(`[Decoder] Identified as S-frame. Control: 0x${controlField[0].toString(16)} 0x${controlField[1].toString(16)}`);
            } else if (lsbBit1 === 0x01) { // U-frame (LSB is 11)
                // U-frames are always 1 byte
                if (unstuffedBytes.length - offset < 1) {
                    throw new Error("U-frame too short for 1 control byte.");
                }
                controlField = unstuffedBytes.slice(offset, offset + 1);
                offset += 1;
                p_f_bit = ((controlField[0] & 0x10) === 0x10); // P/F is bit 4 of first control byte
                isExtended = false; // U-frames don't use extended sequencing for N(S)/N(R)
                logger.debug(`[Decoder] Identified as U-frame. Control: 0x${controlField[0].toString(16)}`);
            } else {
                // This case should theoretically not be reached if LSB is 1 and bit 1 is 0 or 1.
                // But as a fallback, it's good to have.
                logger.error(`[Decoder] Unhandled control field. Byte: 0x${controlFieldByte1.toString(16).padStart(2, '0')}`);
                throw new Error(`Unknown control field type: 0x${controlFieldByte1.toString(16)}`);
            }
        }


        // --- PID Field ---
        let pid: number | null = null;
        // PID is present in I-frames, UI frames, XID, TEST, DM/FRMR
        const decodedControlByte1 = controlField[0];
        const decodedControlByte1WithoutPF = decodedControlByte1 & 0xEF; // Mask P/F for U-frame comparison

        const isIFrame = (decodedControlByte1 & 0x01) === CONTROL_I; // Re-evaluate based on the correct control byte
        const isUIFrame = decodedControlByte1WithoutPF === CONTROL_UI;
        const isXIDFrame = decodedControlByte1WithoutPF === CONTROL_XID;
        const isTestFrame = decodedControlByte1WithoutPF === CONTROL_TEST;
        const isDMOrFRMRFrame = decodedControlByte1WithoutPF === CONTROL_DM; // DM and FRMR share control byte

        if (isIFrame || isUIFrame || isXIDFrame || isTestFrame || isDMOrFRMRFrame) {
            // Check if there's enough data for PID + FCS. Minimum remaining for PID + FCS is 3 bytes (1 PID + 2 FCS)
            if (unstuffedBytes.length - offset >= 3) {
                 pid = unstuffedBytes[offset++];
            } else {
                // If PID is expected but not enough bytes, it's a malformed frame
                throw new Error("Malformed frame: PID expected but not enough bytes.");
            }
        }


        // --- Information Field and FCS ---
        let info: Uint8Array | null = null;
        let fcsBytesReceived: Uint8Array;

        // Calculate expected FCS start point
        const fcsOffset = unstuffedBytes.length - 2;

        if (fcsOffset < offset) { // Not enough bytes for FCS, implies corrupted frame or malformed.
             throw new Error("Frame too short for FCS.");
        }

        info = unstuffedBytes.slice(offset, fcsOffset);
        if (info.length === 0) {
            info = null;
        }

        fcsBytesReceived = unstuffedBytes.slice(fcsOffset, fcsOffset + 2);

        // Validate FCS
        const calculatedFCS = calculateFCS(unstuffedBytes.slice(0, fcsOffset));
        const receivedFCS = fcsBytesReceived[0] | (fcsBytesReceived[1] << 8); // LSB first

        const isValidFCS = calculatedFCS === receivedFCS;

        return {
            source: source,
            destination: destination,
            repeaters,
            control: controlField,
            pid,
            info,
            isValidFCS,
            p_f_bit,
            isCommand: isCommandFrame,
            isExtended: isExtended,
        };
    }
}

// --- Enhanced AX.25 Link State Machine ---
// Changed from enum to const object for better compatibility in some JS environments
const LinkState = {
    DISCONNECTED: 'DISCONNECTED',
    CONNECTING: 'CONNECTING',
    CONNECTED: 'CONNECTED',
    DISCONNECTING: 'DISCONNECTING',
    REJECT_SENT: 'REJECT_SENT',
    FRAME_REJECT_SENT: 'FRAME_REJECT_SENT',
    REMOTE_BUSY: 'REMOTE_BUSY',
} as const; // 'as const' makes values read-only and infers literal types

// Define a type from the object keys for type safety, similar to an enum
type LinkState = typeof LinkState[keyof typeof LinkState];


// --- Error Type for Callbacks ---
enum AX25LinkErrorType {
    FCS_MISMATCH = 'FCS_MISMATCH',
    PROTOCOL_ERROR = 'PROTOCOL_ERROR',
    TIMEOUT = 'TIMEOUT',
    BUFFER_FULL = 'BUFFER_FULL',
    DISCONNECTED = 'DISCONNECTED',
    INVALID_FRAME = 'INVALID_FRAME',
    MAX_RETRIES_EXCEEDED = 'MAX_RETRIES_EXCEEDED',
    NEGOTIATION_FAILED = 'NEGOTIATION_FAILED',
}

interface AX25LinkCallbacks {
    onDataReceived: (data: Uint8Array, source: string, pid: number) => void;
    onUIFrameReceived: (data: Uint8Array, source: string, dest: string, pid: number, repeaters: AX25Address[]) => void;
    onFrameRepeated: (originalSource: string, finalDest: string, repeaterCallsign: string) => void;
    onConnected: (peerCallsign: string, negotiatedParams: XIDParameters | null) => void;
    onDisconnected: (peerCallsign: string, reason?: string) => void;
    onError: (error: AX25Error) => void;
    onStateChange: (newState: LinkState, oldState: LinkState) => void;
    onAcknowledge: (nr: number) => void;
    onBufferStatusChange: (transmitQueueSize: number, receiveBufferSize: number, maxBufferSize: number) => void;
}

class AX25Link {
    // --- Configurable Constants (can be passed in constructor or set) ---
    private T1_TIMEOUT_MS: number; // Retransmission timer
    private T2_TIMEOUT_MS: number; // Response Delay timer
    private T3_TIMEOUT_MS: number; // Inactivity timer
    private MAX_RETRY_COUNT: number;
    private WINDOW_SIZE_K: number; // Default window size
    private MAX_I_FIELD_LENGTH: number; // Default max I-field length

    // --- State and Properties ---
    public state: LinkState = LinkState.DISCONNECTED;
    private readonly localCallsign: string;
    private remoteCallsign: string | null = null; // Peer station callsign
    private remoteCallsignFull: AX25Address | null = null; // Full peer address

    private V_S = 0; // Send state variable
    private V_A = 0; // Acknowledge state variable
    private V_R = 0; // Receive state variable

    private outstandingIFrames: QueuedIFrame[] = [];
    private receiveBuffer: Map<number, Uint8Array> = new Map(); // Stores out-of-sequence I-frames
    private isRemoteBusy = false; // True if peer sent RNR

    private t1Timer: ReturnType<typeof setTimeout> | null = null;
    private t2Timer: ReturnType<typeof setTimeout> | null = null;
    private t3Timer: ReturnType<typeof setTimeout> | null = null;

    private retryCount = 0; // For connect/disconnect retries

    // --- NEW: XID Parameters for this link ---
    public parameters: XIDParameters = {
        supportedFrames: ['I', 'UI', 'SREJ', 'REJ', 'RR', 'RNR'],
        maxIFieldLength: 256,
        windowSize: 7,
        extendedSequencing: false, // Default to 3-bit sequencing (v2.0)
    };
    private peerParameters: XIDParameters | null = null;

    // --- Callbacks ---
    private callbacks: AX25LinkCallbacks;

    private readonly physicalLayerSend: (frameBytes: Uint8Array) => void;
    private readonly encoder: AX25Encoder;
    private readonly decoder: AX25Decoder;

    constructor(
        localCallsign: string,
        sendFunction: (frameBytes: Uint8Array) => void,
        callbacks: Partial<AX25LinkCallbacks> = {}, // Allow partial override
        config?: {
            t1TimeoutMs?: number;
            t2TimeoutMs?: number;
            t3TimeoutMs?: number;
            maxRetryCount?: number;
            windowSizeK?: number;
            maxIFieldLength?: number;
            initialXIDParams?: Partial<XIDParameters>;
        }
    ) {
        this.localCallsign = localCallsign;
        this.physicalLayerSend = sendFunction;
        this.encoder = new AX25Encoder();
        this.decoder = new AX25Decoder();

        // Set configurable parameters with defaults
        this.T1_TIMEOUT_MS = config?.t1TimeoutMs ?? 5000;
        this.T2_TIMEOUT_MS = config?.t2TimeoutMs ?? 200; // Typically short, allows piggybacking
        this.T3_TIMEOUT_MS = config?.t3TimeoutMs ?? 180000; // 3 minutes
        this.MAX_RETRY_COUNT = config?.maxRetryCount ?? 10;
        this.WINDOW_SIZE_K = config?.windowSizeK ?? 7; // K
        this.MAX_I_FIELD_LENGTH = config?.maxIFieldLength ?? 256;

        if (config?.initialXIDParams) {
            this.parameters = { ...this.parameters, ...config.initialXIDParams };
            this.WINDOW_SIZE_K = this.parameters.windowSize;
            this.MAX_I_FIELD_LENGTH = this.parameters.maxIFieldLength;
        }

        // Initialize callbacks with no-op functions
        this.callbacks = {
            onDataReceived: () => { },
            onUIFrameReceived: () => { },
            onFrameRepeated: () => { },
            onConnected: () => { },
            onDisconnected: () => { },
            onError: () => { },
            onStateChange: () => { },
            onAcknowledge: () => { },
            onBufferStatusChange: () => { },
            ...callbacks, // Override with provided callbacks
        };
        logger.info(`AX25Link initialized for ${this.localCallsign} with T1=${this.T1_TIMEOUT_MS}ms, T2=${this.T2_TIMEOUT_MS}ms, T3=${this.T3_TIMEOUT_MS}ms, K=${this.WINDOW_SIZE_K}`);
    }

    // --- State Management ---
    private setState(newState: LinkState): void {
        if (this.state !== newState) {
            logger.info(`[${this.localCallsign}] State change: ${this.state} -> ${newState}`);
            const oldState = this.state;
            this.state = newState;
            this.callbacks.onStateChange(newState, oldState);

            // Reset timers on state change to avoid stale timers interfering
            this.stopAllTimers();

            // Start T3 timer when in CONNECTED state to detect inactivity
            if (newState === LinkState.CONNECTED) {
                this.startT3Timer();
            }
        }
    }

    // --- Timer Management ---
    private startT1Timer(): void {
        this.stopT1Timer();
        this.t1Timer = setTimeout(() => this._handleT1Timeout(), this.T1_TIMEOUT_MS);
        logger.debug(`[${this.localCallsign}] T1 timer started.`);
    }

    private stopT1Timer(): void {
        if (this.t1Timer) {
            clearTimeout(this.t1Timer);
            this.t1Timer = null;
            logger.debug(`[${this.localCallsign}] T1 timer stopped.`);
        }
    }

    private startT2Timer(): void {
        this.stopT2Timer();
        this.t2Timer = setTimeout(() => this._handleT2Timeout(), this.T2_TIMEOUT_MS);
        logger.debug(`[${this.localCallsign}] T2 timer started.`);
    }

    private stopT2Timer(): void {
        if (this.t2Timer) {
            clearTimeout(this.t2Timer);
            this.t2Timer = null;
            logger.debug(`[${this.localCallsign}] T2 timer stopped.`);
        }
    }

    private startT3Timer(): void {
        this.stopT3Timer();
        this.t3Timer = setTimeout(() => this._handleT3Timeout(), this.T3_TIMEOUT_MS);
        logger.debug(`[${this.localCallsign}] T3 timer started.`);
    }

    private stopT3Timer(): void {
        if (this.t3Timer) {
            clearTimeout(this.t3Timer);
            this.t3Timer = null;
            logger.debug(`[${this.localCallsign}] T3 timer stopped.`);
        }
    }

    private stopAllTimers(): void {
        this.stopT1Timer();
        this.stopT2Timer();
        this.stopT3Timer();
    }

    private _handleT1Timeout(): void {
        this.retryCount++;
        logger.warn(`[${this.localCallsign}] T1 Timeout! Retry count: ${this.retryCount}/${this.MAX_RETRY_COUNT}.`);

        if (this.retryCount > this.MAX_RETRY_COUNT) {
            this.callbacks.onError({
                type: AX25LinkErrorType.MAX_RETRIES_EXCEEDED,
                message: `Max retries exceeded (${this.MAX_RETRY_COUNT}). Disconnecting.`
            });
            this.disconnect('T1 Timeout - Max Retries');
            return;
        }

        switch (this.state) {
            case LinkState.CONNECTING:
                this._sendSABME(true); // Re-send SABME with P-bit set
                this.startT1Timer();
                break;
            case LinkState.CONNECTED:
            case LinkState.REJECT_SENT:
            case LinkState.REMOTE_BUSY:
                // Retransmit the oldest unacknowledged I-frame or send an RR with P-bit
                const unackedFrames = this.outstandingIFrames.filter(f => !f.acknowledged);
                if (unackedFrames.length > 0) {
                    // Retransmit all unacknowledged frames if Go-back-N, or just oldest if SREJ isn't active
                    // For simplicity here, if T1 fires, we retransmit the frame at V(A) (oldest unacked)
                    const frameToRetransmit = unackedFrames[0];
                    if (frameToRetransmit) {
                        logger.info(`[${this.localCallsign}] Retransmitting I-frame N(S)=${frameToRetransmit.ns} after T1 timeout.`);
                        this.sendRawFrame(frameToRetransmit.frameBytes);
                        frameToRetransmit.retries++;
                        frameToRetransmit.sentTime = Date.now();
                        this.startT1Timer(); // Restart T1 for this frame
                    }
                } else {
                    // No outstanding I-frames, send an RR with P-bit to poll peer
                    logger.info(`[${this.localCallsign}] No outstanding I-frames, sending RR with P-bit to poll.`);
                    this.sendRR(true, this.V_R);
                    this.startT1Timer();
                }
                break;
            case LinkState.DISCONNECTING:
                this._sendDISC(true); // Re-send DISC with P-bit set
                this.startT1Timer();
                break;
            default:
                logger.warn(`[${this.localCallsign}] T1 timeout in unexpected state: ${this.state}`);
                this.disconnect('T1 Timeout in unexpected state');
                break;
        }
    }

    private _handleT2Timeout(): void {
        logger.debug(`[${this.localCallsign}] T2 Timeout: Sending pending acknowledgement.`);
        // If there's an acknowledgement pending (i.e., V_R has advanced but no frame sent since)
        // or if we just received an I-frame and need to acknowledge it.
        // This is where a delayed RR or RNR would be sent.
        if (this.state === LinkState.CONNECTED || this.state === LinkState.REMOTE_BUSY) {
            if (this.isRemoteBusy) {
                 this.sendRNR(false, this.V_R); // Still busy, send RNR
            } else {
                 this.sendRR(false, this.V_R); // Send RR
            }
        }
    }

    private _handleT3Timeout(): void {
        logger.info(`[${this.localCallsign}] T3 Timeout: Inactivity detected. Sending DISC.`);
        this.disconnect('Inactivity Timeout (T3)');
    }

    // --- Public Methods ---

    /**
     * Initializes a connection to a remote station.
     */
    public connect(destinationCallsign: string): void {
        if (this.state !== LinkState.DISCONNECTED) {
            logger.warn(`[${this.localCallsign}] Already in state ${this.state}. Cannot connect.`);
            return;
        }

        this.remoteCallsign = destinationCallsign;
        this.setState(LinkState.CONNECTING);
        this.V_S = 0;
        this.V_A = 0;
        this.V_R = 0;
        this.retryCount = 0;
        this.outstandingIFrames = [];
        this.receiveBuffer.clear();
        this.isRemoteBusy = false;

        this._sendSABME(true); // Send SABME with P-bit set
        this.startT1Timer(); // Start T1 for SABME retransmissions
    }

    /**
     * Sends a UI (Unnumbered Information) frame.
     */
    public sendUIFrame(destination: string, repeaters: string[], pid: number, data: Uint8Array): void {
        logger.info(`[${this.localCallsign}] Sending UI frame to ${destination}, PID: 0x${pid.toString(16)}`);
        const uiControl = new Uint8Array([CONTROL_UI]);
        // UI frames are typically Commands from the sender's perspective for routing
        // and usually have P/F bit cleared (unless used for polling specific info).
        const frame = this._sendFrame(uiControl, pid, data, true, false, repeaters, destination);
        // No need to check if frame is null here, _sendFrame already logs errors.
    }

    /**
     * Sends an I (Information) frame.
     * Includes logic to respect window size and max I-field length.
     */
    public sendIFrame(data: Uint8Array, pid: number = PID_NO_LAYER_3, repeaters: string[] = []): void {
        if (this.state !== LinkState.CONNECTED) {
            this.callbacks.onError({ type: AX25LinkErrorType.DISCONNECTED, message: `Cannot send I-frame: link is ${this.state}.` });
            logger.warn(`[${this.localCallsign}] Cannot send I-frame, link not CONNECTED. State: ${this.state}`);
            return;
        }
        if (!this.remoteCallsign) {
            logger.error(`[${this.localCallsign}] No remote callsign defined for sending I-frame.`);
            return;
        }

        // Check window size: V(S) - V(A) < K (window size)
        const windowOccupancy = (this.V_S - this.V_A + 128) % 128; // Handle modulo 128 for 7-bit sequence numbers
        if (windowOccupancy >= this.WINDOW_SIZE_K) {
            this.callbacks.onError({ type: AX25LinkErrorType.BUFFER_FULL, message: `Transmit window full. V(S)=${this.V_S}, V(A)=${this.V_A}, K=${this.WINDOW_SIZE_K}.` });
            logger.warn(`[${this.localCallsign}] Transmit window full. V(S)=${this.V_S}, V(A)=${this.V_A}, K=${this.WINDOW_SIZE_K}. Cannot send I-frame.`);
            return;
        }

        if (data.length > this.MAX_I_FIELD_LENGTH) {
            // This is where fragmentation would normally occur for higher layers.
            // For this implementation, we'll error out.
            this.callbacks.onError({ type: AX25LinkErrorType.BUFFER_FULL, message: `I-field length (${data.length}) exceeds maximum (${this.MAX_I_FIELD_LENGTH}).` });
            logger.error(`[${this.localCallsign}] I-field length (${data.length}) exceeds maximum (${this.MAX_I_FIELD_LENGTH}).`);
            return;
        }

        let controlBytes: Uint8Array;
        // AX.25 v2.2 uses 2-byte control field for 7-bit N(S)/N(R) for I-frames:
        // Byte 1: N(S) (bits 1-7, LSB is 0)
        // Byte 2: N(R) (bits 1-7, LSB is P/F bit)
        controlBytes = new Uint8Array([
            (this.V_S << 1) & 0xFE, // I-frame, N(S)
            (this.V_R << 1) & 0xFE // N(R) (P/F bit is LSB of this byte)
        ]);


        const frameBytes = this._sendFrame(controlBytes, pid, data, true, false, repeaters, this.remoteCallsign); // Always command from sender perspective
        if (frameBytes) {
            this.outstandingIFrames.push({
                ns: this.V_S,
                frameBytes: frameBytes,
                retries: 0,
                sentTime: Date.now(),
                acknowledged: false,
            });
            this.V_S = (this.V_S + 1) % 128; // Increment V(S) (modulo 128 for 7-bit sequence numbers)
            this.startT1Timer(); // Start/restart T1 timer for this frame
            this.callbacks.onBufferStatusChange(this.outstandingIFrames.length, this.receiveBuffer.size, this.WINDOW_SIZE_K);
        }
    }

    /**
     * Initiates disconnection.
     */
    public disconnect(reason: string = 'Application Request'): void {
        if (this.state === LinkState.DISCONNECTED || this.state === LinkState.DISCONNECTING) {
            logger.info(`[${this.localCallsign}] Already disconnecting or disconnected.`);
            return;
        }

        logger.info(`[${this.localCallsign}] Disconnecting: ${reason}`);
        this.setState(LinkState.DISCONNECTING);
        this.retryCount = 0;
        this._sendDISC(true); // Send DISC with P-bit set
        this.startT1Timer(); // Start T1 for DISC retransmissions
    }

    /**
     * Sends an RR (Receive Ready) frame.
     */
    public sendRR(isPoll: boolean = false, nr: number): void {
        logger.debug(`[${this.localCallsign}] Sending RR, N(R)=${nr}, P/F=${isPoll}`);
        // S-frames are 2 bytes in Modulo 128
        const controlField = new Uint8Array([
            CONTROL_RR | (isPoll ? 0x10 : 0x00), // First byte: RR type + P/F bit (bit 4)
            (nr << 1) & 0xFE // Second byte: N(R) shifted (LSB 0)
        ]);
        if (!this.remoteCallsign) {
            logger.error(`[${this.localCallsign}] Cannot send RR: remoteCallsign is null.`);
            return;
        }
        this._sendFrame(controlField, null, null, !isPoll, isPoll, [], this.remoteCallsign); // Response unless it's a command poll
        this.stopT2Timer(); // Cancel T2 as an ACK has been sent
    }

    /**
     * Sends an RNR (Receiver Not Ready) frame.
     */
    public sendRNR(isPoll: boolean = false, nr: number): void {
        logger.debug(`[${this.localCallsign}] Sending RNR, N(R)=${nr}, P/F=${isPoll}`);
        this.isRemoteBusy = true; // Mark local as busy
        // S-frames are 2 bytes in Modulo 128
        const controlField = new Uint8Array([
            CONTROL_RNR | (isPoll ? 0x10 : 0x00), // First byte: RNR type + P/F bit (bit 4)
            (nr << 1) & 0xFE // Second byte: N(R) shifted (LSB 0)
        ]);
        if (!this.remoteCallsign) {
            logger.error(`[${this.localCallsign}] Cannot send RNR: remoteCallsign is null.`);
            return;
        }
        this._sendFrame(controlField, null, null, !isPoll, isPoll, [], this.remoteCallsign); // Response unless it's a command poll
        this.stopT2Timer();
    }

    /**
     * Sends an SREJ (Selective Reject) frame.
     */
    public sendSREJ(isPoll: boolean = false, nr: number): void {
        logger.info(`[${this.localCallsign}] Sending SREJ, N(R)=${nr}, P/F=${isPoll}`);
        // S-frames are 2 bytes in Modulo 128
        const controlField = new Uint8Array([
            CONTROL_SREJ | (isPoll ? 0x10 : 0x00), // First byte: SREJ type + P/F bit (bit 4)
            (nr << 1) & 0xFE // Second byte: N(R) shifted (LSB 0)
        ]);
        if (!this.remoteCallsign) {
            logger.error(`[${this.localCallsign}] Cannot send SREJ: remoteCallsign is null.`);
            return;
        }
        this._sendFrame(controlField, null, null, !isPoll, isPoll, [], this.remoteCallsign); // Response unless it's a command poll
        this.stopT2Timer();
    }

    /**
     * Sends an REJ (Reject - Go-back-N) frame.
     */
    public sendREJ(isPoll: boolean = false, nr: number): void {
        logger.warn(`[${this.localCallsign}] Sending REJ (Go-back-N), N(R)=${nr}, P/F=${isPoll}`);
        this.setState(LinkState.REJECT_SENT); // Enter REJECT_SENT state
        // S-frames are 2 bytes in Modulo 128
        const controlField = new Uint8Array([
            CONTROL_REJ | (isPoll ? 0x10 : 0x00), // First byte: REJ type + P/F bit (bit 4)
            (nr << 1) & 0xFE // Second byte: N(R) shifted (LSB 0)
        ]);
        if (!this.remoteCallsign) {
            logger.error(`[${this.localCallsign}] Cannot send REJ: remoteCallsign is null.`);
            return;
        }
        this._sendFrame(controlField, null, null, !isPoll, isPoll, [], this.remoteCallsign); // Response unless it's a command poll
        this.stopT2Timer();
    }

    /**
     * Sends a FRMR (Frame Reject) frame.
     * @param rejectedControl The control field of the rejected frame.
     * @param nr The N(R) value to report.
     * @param vs The V(S) value to report.
     * @param cause A byte indicating the reason for the reject.
     * Bit 0: Invalid N(R)
     * Bit 1: Invalid N(S)
     * Bit 2: Control field invalid or not implemented
     * Bit 3: Information field too long
     * Bit 4: Invalid I-field in supervisory/unnumbered frame (if info present)
     */
    public sendFRMR(
        rejectedControl: Uint8Array,
        reportedVS: number,
        reportedVR: number,
        causeByte: number,
        isPoll: boolean = false
    ): void {
        logger.error(`[${this.localCallsign}] Sending FRMR. Control: 0x${rejectedControl[0].toString(16)}, V(S)=${reportedVS}, V(R)=${reportedVR}, Cause: 0x${causeByte.toString(16)}`);
        this.setState(LinkState.FRAME_REJECT_SENT);

        // FRMR Info Field Format:
        // Byte 0: Rejected Control Field
        // Byte 1: V(S)
        // Byte 2: V(R)
        // Byte 3: W1 (Reject Reason - causeByte)
        // Byte 4: W2 (Reserved, usually 0)
        const infoField = new Uint8Array([
            rejectedControl[0],
            (reportedVS << 1) & 0xFE, // V(S) in rejected frame
            (reportedVR << 1) & 0xFE, // V(R) in rejected frame
            causeByte,
            0x00 // W2 - Reserved
        ]);

        const controlField = new Uint8Array([CONTROL_DM | 0x03]); // Use CONTROL_DM (0x87) for FRMR, as they share the same control byte value.
        if (!this.remoteCallsign) {
            logger.error(`[${this.localCallsign}] Cannot send FRMR: remoteCallsign is null.`);
            return;
        }
        this._sendFrame(controlField, null, infoField, false, isPoll, [], this.remoteCallsign); // FRMR is always a Response, P/F from received frame
        this.stopT2Timer();
    }


    /**
     * General method to send a frame after encoding.
     */
    private _sendFrame(
        control: Uint8Array,
        pid: number | null,
        info: Uint8Array | null,
        isCommand: boolean,
        p_f_bit: boolean,
        repeaters: string[] = [],
        explicitDestination: string | null = null // New parameter
    ): Uint8Array | null {
        const finalDestination = explicitDestination || this.remoteCallsign; // Use explicit if provided

        if (!finalDestination) { // Check against the resolved destination
            logger.error(`[${this.localCallsign}] Cannot send frame: no remote callsign set.`);
            return null;
        }
        try {
            const frameBytes = this.encoder.encodeFrame(
                finalDestination, // Use finalDestination
                this.localCallsign,
                repeaters,
                control,
                pid,
                info,
                isCommand,
                p_f_bit,
                this.localCallsign // Pass local callsign to encoder for accurate H-bit setting
            );
            this.sendRawFrame(frameBytes);
            return frameBytes;
        } catch (e) {
            logger.error(`[${this.localCallsign}] Error encoding/sending frame: ${e instanceof Error ? e.message : String(e)}`);
            this.callbacks.onError({ type: AX25LinkErrorType.PROTOCOL_ERROR, message: `Failed to encode/send frame: ${e}` });
            return null;
        }
    }

    /**
     * Sends the raw, bit-stuffed, flagged frame bytes to the physical layer.
     */
    private sendRawFrame(frameBytes: Uint8Array): void {
        this.physicalLayerSend(frameBytes);
        this.startT3Timer(); // Reset T3 on any outbound activity
    }

    /**
     * Receives raw data from the physical layer and processes it into AX.25 frames.
     */
    public receiveRawData(rawData: Uint8Array): void {
        const frames = this.decoder.processRawData(rawData);
        frames.forEach(frame => {
            this.startT3Timer(); // Any incoming frame resets T3

            if (!frame.isValidFCS) {
                logger.error(`[${this.localCallsign}] Discarding frame from ${frame.source.callsign} with invalid FCS.`);
                this.callbacks.onError({
                    type: AX25LinkErrorType.FCS_MISMATCH,
                    message: `Invalid FCS from ${frame.source.callsign}`,
                    frame: frame
                });
                return;
            }

            // --- NEW: Digipeater Logic ---
            const repeaterIndex = frame.repeaters.findIndex(r => r.callsign === this.localCallsign && !r.hasBeenDigipeated);
            if (repeaterIndex !== -1) {
                logger.info(`[${this.localCallsign}] Acting as a digipeater for frame from ${frame.source.callsign}.`);
                this._repeatFrame(frame, repeaterIndex);
                this.callbacks.onFrameRepeated?.(frame.source.callsign, frame.destination.callsign, this.localCallsign);
                return; // Frame has been repeated, no further processing needed by this station.
            }

            // Check if frame is for us (destination) or a broadcast UI frame
            const isForUs = frame.destination.callsign === this.localCallsign;
            const isUIBroadcast = (frame.control[0] & 0xEF) === CONTROL_UI && frame.destination.callsign === 'CQ'; // Common APRS broadcast dest

            if (!isForUs && !isUIBroadcast) {
                logger.debug(`[${this.localCallsign}] Ignoring frame not for us (dest: ${frame.destination.callsign}, type: 0x${frame.control[0].toString(16)}).`);
                return;
            }

            // If it's for us, set remoteCallsign if not already set (e.g. initial connection)
            if (isForUs && !this.remoteCallsign && this.state !== LinkState.CONNECTING) {
                 this.remoteCallsign = frame.source.callsign;
                 this.remoteCallsignFull = frame.source;
                 logger.info(`[${this.localCallsign}] Remote callsign set to ${this.remoteCallsign}.`);
            }

            this.handleReceivedFrame(frame);
        });
    }

    // --- Private Methods ---

    /**
     * Re-encodes and retransmits a frame with the H-bit set for the current repeater.
     */
    private _repeatFrame(frame: AX25Frame, repeaterIndex: number): void {
        // Create a mutable copy of repeaters array
        const newRepeaters = frame.repeaters.map((r, i) =>
            i === repeaterIndex ? { ...r, hasBeenDigipeated: true } : r
        );

        const repeaterCallsigns = newRepeaters.map(r => r.callsign);

        // Re-encode the frame with the updated repeater address (H-bit set)
        const newFrameBytes = this.encoder.encodeFrame(
            frame.destination.callsign,
            frame.source.callsign,
            repeaterCallsigns, // Use the updated list
            frame.control,
            frame.pid,
            frame.info,
            frame.isCommand, // Preserve original command/response nature
            frame.p_f_bit,   // Preserve original P/F bit
            this.localCallsign // Pass local callsign to encoder for accurate H-bit setting
        );
        this.sendRawFrame(newFrameBytes);
    }

    /**
     * Helper to send SABME.
     * @param isPoll True if P-bit should be set.
     */
    private _sendSABME(isPoll: boolean): void {
        const sabmeControl = new Uint8Array([CONTROL_SABME]);
        // Pass this.remoteCallsign explicitly as destination for SABME
        this._sendFrame(sabmeControl, null, null, true, isPoll, [], this.remoteCallsign);
    }

    /**
     * Helper to send UA.
     * @param isFinal True if F-bit should be set (in response to a P-bit).
     */
    private _sendUA(isFinal: boolean): void {
        const uaControl = new Uint8Array([CONTROL_UA]);
        if (!this.remoteCallsign) {
            logger.error(`[${this.localCallsign}] Cannot send UA: remoteCallsign is null.`);
            return;
        }
        this._sendFrame(uaControl, null, null, false, isFinal, [], this.remoteCallsign); // UA is a Response
    }

    /**
     * Helper to send DM.
     * @param isFinal True if F-bit should be set (in response to a P-bit).
     */
    private _sendDM(isFinal: boolean): void {
        const dmControl = new Uint8Array([CONTROL_DM]);
        // When sending DM, the remoteCallsign might be null if we are in DISCONNECTED state
        // and responding to an unsolicited frame. In this case, use the source of the incoming frame
        // as the destination for the DM.
        const destinationForDM = this.remoteCallsign || 'UNKNOWN-0'; // Fallback if no remoteCallsign
        logger.debug(`[${this.localCallsign}] Sending DM to ${destinationForDM}`);
        this._sendFrame(dmControl, null, null, false, isFinal, [], destinationForDM); // DM is a Response
    }

    /**
     * Helper to send DISC.
     * @param isPoll True if P-bit should be set.
     */
    private _sendDISC(isPoll: boolean): void {
        const discControl = new Uint8Array([CONTROL_DISC]);
        if (!this.remoteCallsign) {
            logger.error(`[${this.localCallsign}] Cannot send DISC: remoteCallsign is null.`);
            return;
        }
        this._sendFrame(discControl, null, null, true, isPoll, [], this.remoteCallsign); // DISC is a Command
    }


    private handleReceivedFrame(frame: AX25Frame): void {
        const controlByte = frame.control[0];
        const isCommand = frame.isCommand; // Determines if frame is command or response
        const p_f_bit = frame.p_f_bit;

        logger.debug(`[${this.localCallsign}] Received frame from ${frame.source.callsign}, Control: 0x${controlByte.toString(16)}, P/F=${p_f_bit}, Cmd=${isCommand}`);

        // Reset T3 timer on any valid frame in connected state
        this.startT3Timer();

        // Handle P/F bit for commands received in connected state
        if (isCommand && p_f_bit) {
            // A command with P-bit set requires an immediate response (UA, DM, RR, RNR, REJ, SREJ, FRMR)
            // This is primarily for polling (e.g., RR P-bit) or link setup/teardown (SABME, DISC)
            logger.debug(`[${this.localCallsign}] Received Command with P-bit set. Preparing response.`);
            this.stopT1Timer(); // Stop T1 as we've received a poll.
        }

        // --- Handle incoming UI frames in any state ---
        if ((controlByte & 0xEF) === CONTROL_UI) { // Mask out P/F bit
            logger.info(`[${this.localCallsign}] Received UI frame from ${frame.source.callsign}.`);
            this.callbacks.onUIFrameReceived?.(frame.info!, frame.source.callsign, frame.destination.callsign, frame.pid || PID_NO_LAYER_3, frame.repeaters);
            return; // UI frames don't alter the connected state, so we often return after processing.
        }

        // --- Handle incoming XID frames ---
        if ((controlByte & 0xEF) === CONTROL_XID) { // Mask out P/F bit
            logger.info(`[${this.localCallsign}] Received XID frame.`);
            if (frame.info) {
                const peerParams = this._parseXIDInfo(frame.info);
                if (peerParams) {
                    this.peerParameters = peerParams;
                    logger.info(`[${this.localCallsign}] Peer XID parameters:`, peerParams);
                    // Adjust our link parameters based on peer's capabilities, if desired
                    // For example, if peer doesn't support SREJ, we disable it for this link.
                    // This.WINDOW_SIZE_K = Math.min(this.WINDOW_SIZE_K, peerParams.windowSize);
                }
            }
            // Respond with our own XID parameters, mirroring P/F bit (Final if poll was set)
            const ourXIDInfo = this._encodeXIDInfo();
            const xidControl = new Uint8Array([CONTROL_XID]);
            this._sendFrame(xidControl, null, ourXIDInfo, false, p_f_bit, [], this.remoteCallsign); // XID response is Response
            return;
        }

        // --- Handle DM and FRMR, which share the same control byte (0x87) ---
        if ((controlByte & 0xEF) === CONTROL_DM) { // This matches both DM and FRMR
            // Distinguish DM from FRMR by the presence and length of the info field.
            // FRMR frames *must* have an info field of 5 bytes. DM frames do not.
            if (frame.info && frame.info.length === 5) {
                logger.error(`[${this.localCallsign}] Received FRMR frame from ${frame.source.callsign}.`);
                const rejectedControl = frame.info[0];
                const reportedVS = (frame.info[1] >>> 1) & 0x7F;
                const reportedVR = (frame.info[2] >>> 1) & 0x7F;
                const cause = frame.info[3];
                logger.error(`[${this.localCallsign}] FRMR Details: Rejected Ctl: 0x${rejectedControl.toString(16)}, Our V(S)=${reportedVS}, Our V(R)=${reportedVR}, Cause: 0x${cause.toString(16)}`);
                this.callbacks.onError({
                    type: AX25LinkErrorType.PROTOCOL_ERROR,
                    message: `Received FRMR from ${frame.source.callsign}. Link likely in error state.`,
                    frame: frame
                });
                this.disconnect('Received FRMR');
                return;
            } else { // Otherwise, it's a DM (Disconnected Mode)
                // Handle DM based on state
                logger.info(`[${this.localCallsign}] Received DM frame from ${frame.source.callsign}.`);
                switch (this.state) {
                    case LinkState.DISCONNECTED:
                        logger.info(`[${this.localCallsign}] Received DM in DISCONNECTED state. No action.`);
                        break;
                    case LinkState.CONNECTING:
                        if (p_f_bit) {
                            logger.warn(`[${this.localCallsign}] Received DM (Final) from ${frame.source.callsign}. Peer is in disconnected mode.`);
                            this.stopT1Timer();
                            this.disconnect('Peer in Disconnected Mode (DM)');
                            this.callbacks.onError({ type: AX25LinkErrorType.NEGOTIATION_FAILED, message: `Connection failed: Peer sent DM.` });
                        } else {
                            logger.warn(`[${this.localCallsign}] Received unsolicited DM in CONNECTING state. Ignoring.`);
                        }
                        break;
                    case LinkState.CONNECTED:
                        logger.warn(`[${this.localCallsign}] Received unsolicited DM in CONNECTED state. Peer may have dropped connection.`);
                        this.disconnect('Received unsolicited DM');
                        break;
                    case LinkState.DISCONNECTING:
                        if (p_f_bit) {
                            logger.info(`[${this.localCallsign}] Received DM (Final) from ${frame.source.callsign}. Disconnected.`);
                            this.stopT1Timer();
                            this.setState(LinkState.DISCONNECTED);
                            this.remoteCallsign = null;
                            this.remoteCallsignFull = null;
                            this.callbacks.onDisconnected(frame.source.callsign, 'Peer in Disconnected Mode (DM)');
                        } else {
                            logger.warn(`[${this.localCallsign}] Received unsolicited DM in DISCONNECTING state. Ignoring.`);
                        }
                        break;
                    case LinkState.REJECT_SENT:
                    case LinkState.FRAME_REJECT_SENT:
                    case LinkState.REMOTE_BUSY:
                        logger.warn(`[${this.localCallsign}] Received DM in special state ${this.state}. Disconnecting.`);
                        this.disconnect('Received DM in special state');
                        break;
                }
            }
            return; // Handled DM/FRMR, return
        }

        // Main state machine logic for other frame types
        switch (this.state) {
            case LinkState.DISCONNECTED:
                if (isCommand && (controlByte & 0xEF) === CONTROL_SABME) {
                    logger.info(`[${this.localCallsign}] Received SABME from ${frame.source.callsign}. Sending UA.`);
                    this.remoteCallsign = frame.source.callsign;
                    this.remoteCallsignFull = frame.source;
                    this.V_S = 0;
                    this.V_A = 0;
                    this.V_R = 0;
                    this.outstandingIFrames = [];
                    this.receiveBuffer.clear();
                    this.isRemoteBusy = false;
                    this.setState(LinkState.CONNECTED);
                    this._sendUA(p_f_bit); // Respond with UA, setting F-bit if P-bit was set
                    this.callbacks.onConnected(this.remoteCallsign, this.peerParameters);
                } else if (isCommand && (controlByte & 0xEF) === CONTROL_DISC) {
                    logger.info(`[${this.localCallsign}] Received DISC from ${frame.source.callsign} in DISCONNECTED state. Sending DM.`);
                    // When responding with DM, use the source of the incoming frame as the destination
                    this._sendDM(p_f_bit); // Respond with DM, setting F-bit if P-bit was set
                } else {
                    logger.warn(`[${this.localCallsign}] Received unexpected frame in DISCONNECTED state: Ctl=0x${controlByte.toString(16)}. Responding with DM if command.`);
                    // If it's a command, respond with DM (e.g., unsolicited I-frame)
                    if (isCommand) {
                        this._sendDM(p_f_bit);
                    }
                }
                break;

            case LinkState.CONNECTING:
                if (!isCommand && (controlByte & 0xEF) === CONTROL_UA && p_f_bit) {
                    logger.info(`[${this.localCallsign}] Received UA (Final) from ${frame.source.callsign}. Connection established.`);
                    this.stopT1Timer();
                    this.setState(LinkState.CONNECTED);
                    this.retryCount = 0;
                    this.callbacks.onConnected(frame.source.callsign, this.peerParameters);
                } else if (!isCommand && (controlByte & 0xEF) === CONTROL_DM && p_f_bit) { // DM handled above, but keeping for clarity if flow changes
                    logger.warn(`[${this.localCallsign}] Received DM (Final) from ${frame.source.callsign}. Peer is in disconnected mode.`);
                    this.stopT1Timer();
                    this.disconnect('Peer in Disconnected Mode (DM)');
                    this.callbacks.onError({ type: AX25LinkErrorType.NEGOTIATION_FAILED, message: `Connection failed: Peer sent DM.` });
                } else {
                    logger.warn(`[${this.localCallsign}] Received unexpected frame in CONNECTING state: Ctl=0x${controlByte.toString(16)}, P/F=${p_f_bit}, Cmd=${isCommand}`);
                    // If it has the final bit set, it's a response to our poll.
                    if (p_f_bit) {
                        this.callbacks.onError({ type: AX25LinkErrorType.PROTOCOL_ERROR, message: `Unexpected response to SABME: 0x${controlByte.toString(16)}` });
                        this.disconnect('Protocol Error during connection');
                    }
                }
                break;

            case LinkState.CONNECTED:
            case LinkState.REJECT_SENT:
            case LinkState.REMOTE_BUSY:
                this._handleFrameInConnectedState(frame);
                break;

            case LinkState.DISCONNECTING:
                if (!isCommand && (controlByte & 0xEF) === CONTROL_UA && p_f_bit) {
                    logger.info(`[${this.localCallsign}] Received UA (Final) from ${frame.source.callsign}. Disconnected.`);
                    this.stopT1Timer();
                    this.setState(LinkState.DISCONNECTED);
                    this.remoteCallsign = null;
                    this.remoteCallsignFull = null;
                    this.callbacks.onDisconnected(frame.source.callsign, 'Acknowledged DISC');
                } else if (!isCommand && (controlByte & 0xEF) === CONTROL_DM && p_f_bit) { // DM handled above, but keeping for clarity if flow changes
                    logger.info(`[${this.localCallsign}] Received DM (Final) from ${frame.source.callsign}. Disconnected.`);
                    this.stopT1Timer();
                    this.setState(LinkState.DISCONNECTED);
                    this.remoteCallsign = null;
                    this.remoteCallsignFull = null;
                    this.callbacks.onDisconnected(frame.source.callsign, 'Peer in Disconnected Mode (DM)');
                } else {
                    logger.warn(`[${this.localCallsign}] Received unexpected frame in DISCONNECTING state: Ctl=0x${controlByte.toString(16)}`);
                    // Could send DM if it's a command, or ignore if it's an I-frame/S-frame for an already closing link.
                    if (isCommand) {
                        this._sendDM(p_f_bit); // Respond with DM to any unexpected command
                    }
                }
                break;

            case LinkState.FRAME_REJECT_SENT:
                logger.warn(`[${this.localCallsign}] Received frame while in FRAME_REJECT_SENT. Disconnecting.`);
                this.disconnect('Received frame after FRMR sent');
                break;
        }
    }

    private _handleFrameInConnectedState(frame: AX25Frame): void {
        const controlByte = frame.control[0];
        const isCommand = frame.isCommand;
        const p_f_bit = frame.p_f_bit;

        // Reset T3 timer on any valid frame in connected state
        this.startT3Timer();

        // Handle P/F bit for commands received in connected state
        if (isCommand && p_f_bit) {
            // A command with P-bit set requires an immediate response (UA, DM, RR, RNR, REJ, SREJ, FRMR)
            // This is primarily for polling (e.g., RR P-bit) or link setup/teardown (SABME, DISC)
            logger.debug(`[${this.localCallsign}] Received Command with P-bit set. Preparing response.`);
            this.stopT1Timer(); // Stop T1 as we've received a poll.
        }

        // --- I-Frame Handling ---
        if ((controlByte & 0x01) === CONTROL_I) { // Check LSB for I-frame (0)
            const N_S_Received = (controlByte >>> 1) & 0x7F; // N(S) for 7-bit sequencing
            // N(R) for 7-bit sequencing is always from the second control byte for I-frames
            const N_R_Received = (frame.control[1] >>> 1) & 0x7F;

            logger.debug(`[${this.localCallsign}] Received I-frame N(S)=${N_S_Received}, N(R)=${N_R_Received}. Expected V(R)=${this.V_R}.`);

            this.acknowledgeOutstandingFrames(N_R_Received);
            this.callbacks.onAcknowledge(N_R_Received);

            if (N_S_Received === this.V_R) {
                // In-sequence I-frame
                logger.info(`[${this.localCallsign}] Received in-sequence I-frame N(S)=${N_S_Received}.`);
                this.callbacks.onDataReceived?.(frame.info!, frame.source.callsign, frame.pid || PID_NO_LAYER_3);
                this.V_R = (this.V_R + 1) % 128; // Increment V(R)

                // Check receive buffer for consecutively expected frames
                while (this.receiveBuffer.has(this.V_R)) {
                    const bufferedInfo = this.receiveBuffer.get(this.V_R)!;
                    logger.info(`[${this.localCallsign}] Delivering buffered I-frame N(S)=${this.V_R}.`);
                    this.callbacks.onDataReceived?.(bufferedInfo, frame.source.callsign, frame.pid || PID_NO_LAYER_3); // PID assumed same as original
                    this.receiveBuffer.delete(this.V_R);
                    this.V_R = (this.V_R + 1) % 128;
                }

                // If remote was busy and we are now ready to receive more, send RR
                if (this.isRemoteBusy && this.receiveBuffer.size < (this.WINDOW_SIZE_K / 2)) { // Heuristic: if buffer half-empty
                    this.isRemoteBusy = false;
                    this.sendRR(p_f_bit, this.V_R);
                } else {
                    this.startT2Timer(); // Start T2 to send a delayed RR/RNR if no outbound I-frame
                }

            } else if (this.isSequenceInWindow(N_S_Received, this.V_R, this.WINDOW_SIZE_K)) {
                // Out-of-sequence I-frame within window
                if (this.receiveBuffer.has(N_S_Received)) {
                    logger.warn(`[${this.localCallsign}] Received duplicate I-frame N(S)=${N_S_Received}. Discarding.`);
                    // Send RR with current V(R) if P-bit was set, otherwise do nothing
                    if (isCommand && p_f_bit) {
                        this.sendRR(true, this.V_R);
                    }
                } else {
                    logger.warn(`[${this.localCallsign}] Received out-of-sequence I-frame N(S)=${N_S_Received}. Expected ${this.V_R}. Buffering.`);
                    this.receiveBuffer.set(N_S_Received, frame.info!);
                    // Immediately send SREJ for V(R) (the missing frame) if not already in REJECT_SENT or REMOTE_BUSY
                    if (this.state !== LinkState.REJECT_SENT && this.state !== LinkState.REMOTE_BUSY) {
                         this.sendSREJ(p_f_bit, this.V_R);
                    } else {
                         // If already in REJECT_SENT (Go-back-N), then another REJ will be sent after T1.
                         // If REMOTE_BUSY, we might send RNR.
                         this.startT2Timer(); // Still acknowledge if no SREJ sent
                    }
                }
            } else {
                // I-frame outside window - Protocol error
                logger.error(`[${this.localCallsign}] Received I-frame N(S)=${N_S_Received} outside window. Expected V(R)=${this.V_R}. Sending FRMR.`);
                const cause = 0x01; // Invalid N(S)
                this.sendFRMR(frame.control, this.V_S, this.V_R, cause, p_f_bit);
            }
        }
        // --- Supervisory (S) Frame Handling ---
        else if ((controlByte & 0x03) === CONTROL_S) { // Check LSBs for S-frame (01)
            const sType = (controlByte >>> 2) & 0x03; // Bits 2,3 for S-frame type (RR, RNR, REJ, SREJ)
            // N(R) for 7-bit sequencing is always from the second control byte for S-frames
            const N_R_Received = (frame.control[1] >>> 1) & 0x7F;

            this.acknowledgeOutstandingFrames(N_R_Received);
            this.callbacks.onAcknowledge(N_R_Received);

            switch (sType) {
                case (CONTROL_RR >>> 2): // RR
                    logger.info(`[${this.localCallsign}] Received RR with N(R)=${N_R_Received}.`);
                    this.isRemoteBusy = false; // Peer is ready to receive
                    // If we were in REJECT_SENT, RR indicates peer is now ready for normal flow
                    if (this.state === LinkState.REJECT_SENT) {
                        this.setState(LinkState.CONNECTED);
                    }
                    break;
                case (CONTROL_RNR >>> 2): // RNR
                    logger.warn(`[${this.localCallsign}] Received RNR with N(R)=${N_R_Received}. Peer is busy.`);
                    this.isRemoteBusy = true; // Mark peer as busy, stop sending I-frames
                    this.setState(LinkState.REMOTE_BUSY);
                    break;
                case (CONTROL_REJ >>> 2): // REJ (Go-back-N)
                    logger.warn(`[${this.localCallsign}] Received REJ with N(R)=${N_R_Received}. Retransmitting from V(A).`);
                    this.isRemoteBusy = false; // Peer is not busy, just needs retransmission
                    this.setState(LinkState.REJECT_SENT); // Enter REJECT_SENT state
                    this._retransmitFromVA(N_R_Received);
                    break;
                case (CONTROL_SREJ >>> 2): // SREJ
                    logger.info(`[${this.localCallsign}] Received SREJ with N(R)=${N_R_Received}. Retransmitting single frame.`);
                    this.isRemoteBusy = false; // Peer is not busy, just needs single retransmission
                    this._retransmitSingleFrame(N_R_Received);
                    break;
                default:
                    logger.warn(`[${this.localCallsign}] Received unknown S-frame type: 0x${controlByte.toString(16)}. Sending FRMR.`);
                    const cause = 0x04; // Control field invalid
                    this.sendFRMR(frame.control, this.V_S, this.V_R, cause, p_f_bit);
                    break;
            }
        }
        // --- Unnumbered (U) Frame Handling (excluding UI, XID, DM/FRMR already handled) ---
        else if ((controlByte & 0x03) === CONTROL_U) { // Check LSBs for U-frame (11)
            if (isCommand && (controlByte & 0xEF) === CONTROL_SABME) {
                logger.info(`[${this.localCallsign}] Received SABME in CONNECTED state. Responding with UA.`);
                this._sendUA(p_f_bit); // Acknowledge it, as if connection was re-initiated
                this.V_S = 0; // Reset sequence numbers as per spec on SABM/SABME
                this.V_A = 0;
                this.V_R = 0;
                this.outstandingIFrames = [];
                this.receiveBuffer.clear();
                this.isRemoteBusy = false;
            } else if (isCommand && (controlByte & 0xEF) === CONTROL_DISC) {
                logger.info(`[${this.localCallsign}] Received DISC in CONNECTED state. Sending UA and disconnecting.`);
                this._sendUA(p_f_bit); // Respond with UA
                this.disconnect('Peer Disconnected');
            } else if (!isCommand && (controlByte & 0xEF) === CONTROL_UA) {
                 // Unsolicited UA in CONNECTED state, ignore. Or maybe a late UA from a previous connection attempt
                 logger.warn(`[${this.localCallsign}] Received unsolicited UA in CONNECTED state. Ignoring.`);
            } else {
                logger.warn(`[${this.localCallsign}] Received unknown U-frame type in CONNECTED state: 0x${controlByte.toString(16)}. Sending FRMR.`);
                const cause = 0x04; // Control field invalid
                this.sendFRMR(frame.control, this.V_S, this.V_R, cause, p_f_bit);
            }
        }
    }


    /**
     * Advances V(A) and removes acknowledged I-frames from outstanding queue.
     * @param nr The N(R) received from the peer.
     */
    private acknowledgeOutstandingFrames(nr: number): void {
        this.stopT1Timer(); // Stop T1, it will be restarted if there are unacked frames left.
        let framesAcknowledged = 0;
        let nextVA = this.V_A;

        for (let i = 0; i < this.outstandingIFrames.length; i++) {
            const frame = this.outstandingIFrames[i];
            // Check if frame.ns is between V(A) and nr (exclusive of nr)
            // Handle sequence number wrap-around (modulo 128)
            const isAcknowledged = (frame.ns >= nextVA && frame.ns < nr) || // Normal case
                                   (nextVA > nr && (frame.ns >= nextVA || frame.ns < nr)); // Wrap-around case

            if (isAcknowledged) {
                frame.acknowledged = true;
                framesAcknowledged++;
                nextVA = (frame.ns + 1) % 128; // Advance next V(A)
                logger.debug(`[${this.localCallsign}] I-frame N(S)=${frame.ns} acknowledged by N(R)=${nr}.`);
            } else if (frame.ns === nr) {
                // This means NR points to the next *expected* frame. Frames *before* NR are acknowledged.
                // No action for frame.ns === nr itself.
            }
        }
        this.V_A = nr; // V(A) always becomes the received N(R)

        // Remove acknowledged frames from the beginning of the queue
        while (this.outstandingIFrames.length > 0 && this.outstandingIFrames[0].acknowledged) {
            this.outstandingIFrames.shift();
        }

        // Restart T1 if there are still unacknowledged frames (even if they are SREJed)
        if (this.outstandingIFrames.length > 0) {
            this.startT1Timer();
        } else {
            this.stopT1Timer(); // All outstanding frames acknowledged
        }
        this.callbacks.onBufferStatusChange(this.outstandingIFrames.length, this.receiveBuffer.size, this.WINDOW_SIZE_K);
    }

    /**
     * Retransmits a single I-frame based on N(R) from an SREJ.
     * @param ns The N(S) of the frame to retransmit (which is the N(R) of the SREJ).
     */
    private _retransmitSingleFrame(ns: number): void {
        const frameToResend = this.outstandingIFrames.find(f => f.ns === ns);
        if (frameToResend && frameToResend.retries < this.MAX_RETRY_COUNT) {
            logger.info(`[${this.localCallsign}] Retrying single I-frame N(S)=${ns} per SREJ.`);
            this.sendRawFrame(frameToResend.frameBytes);
            frameToResend.retries++;
            frameToResend.sentTime = Date.now();
            this.startT1Timer(); // Keep T1 running for this retransmission
        } else if (frameToResend && frameToResend.retries >= this.MAX_RETRY_COUNT) {
            logger.error(`[${this.localCallsign}] Max retries for SREJ frame N(S)=${ns} exceeded.`);
            this.callbacks.onError({
                type: AX25LinkErrorType.MAX_RETRIES_EXCEEDED,
                message: `Max retries for SREJ frame N(S)=${ns} exceeded. Disconnecting.`
            });
            this.disconnect('SREJ max retries');
        } else {
            logger.warn(`[${this.localCallsign}] SREJ received for unknown or already acknowledged frame N(S)=${ns}.`);
        }
    }

    /**
     * Retransmits all outstanding I-frames starting from N(R) received in REJ (Go-back-N).
     * @param nr The N(R) received from the REJ.
     */
    private _retransmitFromVA(nr: number): void {
        this.V_A = nr; // Go-back-N sets V(A) to the N(R) of the REJ
        this.stopT1Timer(); // Stop T1, it will be restarted

        let retransmittedCount = 0;
        for (const frame of this.outstandingIFrames) {
            // Check if frame.ns is between V(A) and V(S) (inclusive of V(A))
            const isToRetransmit = (frame.ns >= this.V_A && frame.ns < this.V_S) || // Normal case
                                    (this.V_A > this.V_S && (frame.ns >= this.V_A || frame.ns < this.V_S)); // Wrap-around case

            if (isToRetransmit) {
                if (frame.retries < this.MAX_RETRY_COUNT) {
                    logger.info(`[${this.localCallsign}] Retransmitting I-frame N(S)=${frame.ns} per REJ.`);
                    this.sendRawFrame(frame.frameBytes);
                    frame.retries++;
                    frame.sentTime = Date.now();
                    retransmittedCount++;
                } else {
                    logger.error(`[${this.localCallsign}] Max retries for REJ frame N(S)=${frame.ns} exceeded.`);
                    this.callbacks.onError({
                        type: AX25LinkErrorType.MAX_RETRIES_EXCEEDED,
                        message: `Max retries for REJ frame N(S)=${frame.ns} exceeded. Disconnecting.`
                    });
                    this.disconnect('REJ max retries');
                    return; // Stop retransmitting
                }
            }
        }
        if (retransmittedCount > 0) {
            this.startT1Timer(); // Restart T1 if frames were retransmitted
        } else {
            logger.info(`[${this.localCallsign}] REJ received but no frames to retransmit (perhaps already ACKed or sent later).`);
        }
    }

    /**
     * Checks if a sequence number is within the current receive window.
     * Handles modulo arithmetic for wrap-around.
     * @param seq The sequence number to check (N(S) of received frame).
     * @param vr The current V(R) (expected next receive sequence number).
     * @param windowSize The window size K.
     */
    private isSequenceInWindow(seq: number, vr: number, windowSize: number): boolean {
        // Calculate the difference, handling wrap-around.
        // `diff` is how many frames ahead `seq` is from `vr`.
        let diff = (seq - vr + 128) % 128;
        return diff < windowSize;
    }

    /**
     * Encodes this link's parameters into an XID information field.
     * This is a simplified byte-level encoding for demonstration.
     * Real AX.25 XID uses specific TLV-like structures (e.g., param type, length, value).
     * For example, TAPR TNCs often have a structure like:
     * [0x01] (Type: MIB Object) [0x02] (Length: 2 bytes) [0x07] (Window Size: K) [0x00] (Reserved)
     * [0x02] (Type: Max Info Length) [0x02] (Length: 2 bytes) [LSB] [MSB]
     */
    private _encodeXIDInfo(): Uint8Array {
        const params: number[] = [];

        // Parameter 1: Window Size (K) - Type 0x01, Length 0x01, Value (K)
        params.push(0x01, 0x01, this.parameters.windowSize);

        // Parameter 2: Max I-Field Length - Type 0x02, Length 0x02, Value (LSB, MSB)
        params.push(0x02, 0x02, this.parameters.maxIFieldLength & 0xFF, (this.parameters.maxIFieldLength >> 8) & 0xFF);

        // Parameter 3: Supported Features (Simplified: 1 byte bitmap) - Type 0x03, Length 0x01, Value
        // Bit 0: I-frame, Bit 1: UI-frame, Bit 2: SREJ, Bit 3: REJ, Bit 4: RR, Bit 5: RNR, Bit 6: Extended Sequencing
        let featureByte = 0;
        if (this.parameters.supportedFrames.includes('I')) featureByte |= (1 << 0);
        if (this.parameters.supportedFrames.includes('UI')) featureByte |= (1 << 1);
        if (this.parameters.supportedFrames.includes('SREJ')) featureByte |= (1 << 2);
        if (this.parameters.supportedFrames.includes('REJ')) featureByte |= (1 << 3);
        if (this.parameters.supportedFrames.includes('RR')) featureByte |= (1 << 4);
        if (this.parameters.supportedFrames.includes('RNR')) featureByte |= (1 << 5);
        if (this.parameters.extendedSequencing) featureByte |= (1 << 6);
        params.push(0x03, 0x01, featureByte);

        return new Uint8Array(params);
    }

    /**
     * Parses XID information field from a peer.
     * Matches the simplified byte-level encoding from _encodeXIDInfo.
     */
    private _parseXIDInfo(data: Uint8Array): XIDParameters | null {
        try {
            const peerParams: XIDParameters = {
                supportedFrames: [],
                maxIFieldLength: 256,
                windowSize: 7,
                extendedSequencing: false,
            };
            let offset = 0;
            while (offset < data.length) {
                const type = data[offset++];
                const length = data[offset++];
                if (offset + length > data.length) {
                    throw new Error("XID parameter length exceeds remaining data.");
                }

                switch (type) {
                    case 0x01: // Window Size (K)
                        if (length === 1) peerParams.windowSize = data[offset];
                        break;
                    case 0x02: // Max I-Field Length
                        if (length === 2) peerParams.maxIFieldLength = data[offset] | (data[offset + 1] << 8);
                        break;
                    case 0x03: // Supported Features
                        if (length === 1) {
                            const featureByte = data[offset];
                            if ((featureByte >> 0) & 0x01) peerParams.supportedFrames.push('I');
                            if ((featureByte >> 1) & 0x01) peerParams.supportedFrames.push('UI');
                            if ((featureByte >> 2) & 0x01) peerParams.supportedFrames.push('SREJ');
                            if ((featureByte >> 3) & 0x01) peerParams.supportedFrames.push('REJ');
                            if ((featureByte >> 4) & 0x01) peerParams.supportedFrames.push('RR');
                            if ((featureByte >> 5) & 0x01) peerParams.supportedFrames.push('RNR');
                            if ((featureByte >> 6) & 0x01) peerParams.extendedSequencing = true;
                        }
                        break;
                    // Add more cases for other XID parameters if needed
                }
                offset += length;
            }
            return peerParams;
        } catch (e) {
            logger.error("Failed to parse XID info:", e);
            return null;
        }
    }
}

// --- React Implementation (useAx25Link Hook & App Component) ---

interface Ax25LinkHookResult {
    connectionStatus: LinkState;
    connectedPeer: string | null;
    messages: { id: number; text: string; type: 'info' | 'ui' | 'error' | 'system' }[];
    transmitQueueSize: number;
    receiveBufferSize: number;
    maxWindowSize: number;
    connect: (destinationCallsign: string) => void;
    disconnect: () => void;
    sendIFrame: (data: Uint8Array, pid?: number, repeaters?: string[]) => void;
    sendUIFrame: (destination: string, repeaters: string[], pid: number, data: Uint8Array) => void;
    receiveRawData: (data: Uint8Array) => void;
    setLogLevel: (level: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR') => void;
}

function useAx25Link(
    localCallsign: string,
    // Simulate a physical layer by providing a function that sends data to *another* AX25Link instance's receiveRawData
    sendFunction: (frameBytes: Uint8Array) => void,
    config?: {
        t1TimeoutMs?: number;
        t2TimeoutMs?: number;
        t3TimeoutMs?: number;
        maxRetryCount?: number;
        windowSizeK?: number;
        maxIFieldLength?: number;
        initialXIDParams?: Partial<XIDParameters>;
        logLevel?: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR';
    }
): Ax25LinkHookResult {
    const linkRef = useRef<AX25Link | null>(null);
    const [connectionStatus, setConnectionStatus] = useState<LinkState>(LinkState.DISCONNECTED);
    const [connectedPeer, setConnectedPeer] = useState<string | null>(null);
    const [messages, setMessages] = useState<{ id: number; text: string; type: 'info' | 'ui' | 'error' | 'system' }[]>([]);
    const [transmitQueueSize, setTransmitQueueSize] = useState(0);
    const [receiveBufferSize, setReceiveBufferSize] = useState(0);
    const [maxWindowSize, setMaxWindowSize] = useState(config?.windowSizeK ?? 7);

    const messageIdRef = useRef(0);

    const addMessage = useCallback((text: string, type: 'info' | 'ui' | 'error' | 'system') => {
        setMessages(prev => [...prev, { id: messageIdRef.current++, text, type }]);
    }, []);

    // Set initial log level for the global logger instance
    useEffect(() => {
        if (config?.logLevel) {
            Logger.getInstance().logLevel = config.logLevel;
        }
    }, [config?.logLevel]);

    useEffect(() => {
        // Create callback functions for the AX25Link instance
        const linkCallbacks: AX25LinkCallbacks = {
            onDataReceived: (data, source, pid) => {
                addMessage(`DATA from ${source} (PID: 0x${pid.toString(16)}): ${new TextDecoder().decode(data)}`, 'info');
            },
            onUIFrameReceived: (data, source, dest, pid, repeaters) => {
                const repeaterStr = repeaters.length > 0 ? ` via ${repeaters.map(r => r.callsign + (r.hasBeenDigipeated ? '*' : '')).join(',')}` : '';
                addMessage(`UI Frame from ${source} to ${dest} (PID: 0x${pid.toString(16)})${repeaterStr}: ${new TextDecoder().decode(data)}`, 'ui');
            },
            onFrameRepeated: (originalSource, finalDest, repeaterCallsign) => {
                addMessage(`Repeated frame from ${originalSource} to ${finalDest} (as ${repeaterCallsign})`, 'system');
            },
            onConnected: (peer, negotiatedParams) => {
                setConnectionStatus(LinkState.CONNECTED);
                setConnectedPeer(peer);
                addMessage(`Connected to ${peer}! Negotiated params: ${JSON.stringify(negotiatedParams)}`, 'system');
            },
            onDisconnected: (peer, reason) => {
                setConnectionStatus(LinkState.DISCONNECTED);
                setConnectedPeer(null);
                addMessage(`Disconnected from ${peer || 'peer'}! Reason: ${reason}`, 'system');
            },
            onError: (error) => {
                addMessage(`ERROR [${error.type}]: ${error.message}`, 'error');
                console.error("AX25Link Error:", error);
            },
            onStateChange: (newState, oldState) => {
                setConnectionStatus(newState);
                addMessage(`State Changed: ${oldState} -> ${newState}`, 'system');
            },
            onAcknowledge: (nr) => {
                // addMessage(`ACKed N(R)=${nr}`, 'system'); // Too verbose for general display
            },
            onBufferStatusChange: (txQueue, rxBuffer, maxWindow) => {
                setTransmitQueueSize(txQueue);
                setReceiveBufferSize(rxBuffer);
                setMaxWindowSize(maxWindow);
            }
        };

        const link = new AX25Link(localCallsign, sendFunction, linkCallbacks, config);
        linkRef.current = link;

        // Cleanup
        return () => {
            if (linkRef.current) {
                linkRef.current.disconnect('Component Unmount');
                linkRef.current = null;
            }
        };
    }, [localCallsign, sendFunction, addMessage, config]); // Re-create link if these props change

    // Memoize the public API functions
    const connect = useCallback((destinationCallsign: string) => {
        linkRef.current?.connect(destinationCallsign);
    }, []);

    const disconnect = useCallback(() => {
        linkRef.current?.disconnect();
    }, []);

    const sendIFrame = useCallback((data: Uint8Array, pid?: number, repeaters?: string[]) => {
        linkRef.current?.sendIFrame(data, pid, repeaters);
    }, []);

    const sendUIFrame = useCallback((destination: string, repeaters: string[], pid: number, data: Uint8Array) => {
        linkRef.current?.sendUIFrame(destination, repeaters, pid, data);
    }, []);

    const receiveRawData = useCallback((data: Uint8Array) => {
        linkRef.current?.receiveRawData(data);
    }, []);

    const setLogLevel = useCallback((level: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR') => {
        Logger.getInstance().logLevel = level;
        addMessage(`Log level set to: ${level}`, 'system');
    }, [addMessage]);

    return {
        connectionStatus,
        connectedPeer,
        messages,
        transmitQueueSize,
        receiveBufferSize,
        maxWindowSize,
        connect,
        disconnect,
        sendIFrame,
        sendUIFrame,
        receiveRawData,
        setLogLevel
    };
}

// --- PID Constants for UI ---
const PIDS = {
    NO_LAYER_3: 0xF0,
    AX25_L3: 0x01, // Example for AX.25 Layer 3 (often specific to implementations)
    IP: 0xCC,      // ARPA Internet Protocol
    ARP: 0xCD,     // ARPA Address Resolution Protocol
    NET_ROM: 0xCF, // NET/ROM
    TEXT: 0xC3,    // TEXNET datagram protocol (sometimes used for generic text, though 0xF0 is common)
};

function App() {
    const [nodeACallsign, setNodeACallsign] = useState('NODEA-1');
    const [nodeBCallsign, setNodeBCallsign] = useState('NODEB-1');
    const [targetCallsign, setTargetCallsign] = useState('NODEB-1');
    const [iMessage, setIMessage] = useState('');
    const [uiMessage, setUiMessage] = useState('');
    const [uiDest, setUiDest] = useState('CQ'); // Default for UI frames (e.g., APRS)
    const [uiPid, setUiPid] = useState<number>(PIDS.NO_LAYER_3);
    const [uiRepeaters, setUiRepeaters] = useState(''); // Comma-separated repeaters

    // Simulate two AX.25 nodes communicating over a shared "physical layer" (a queue)
    const sharedPhysicalLayerQueue = useRef<Uint8Array[]>([]);

    const sendDataToNodeA = useCallback((frameBytes: Uint8Array) => {
        // In a real system, this would be serial port, UDP, etc.
        // Here, we push to a queue that NodeA's receiveRawData will consume.
        sharedPhysicalLayerQueue.current.push(frameBytes);
        setTimeout(() => {
            if (nodeA.receiveRawData) {
                const data = sharedPhysicalLayerQueue.current.shift();
                if (data) nodeA.receiveRawData(data);
            }
        }, 50); // Simulate some transmission delay
    }, []);

    const sendDataToNodeB = useCallback((frameBytes: Uint8Array) => {
        sharedPhysicalLayerQueue.current.push(frameBytes);
        setTimeout(() => {
            if (nodeB.receiveRawData) {
                const data = sharedPhysicalLayerQueue.current.shift();
                if (data) nodeB.receiveRawData(data);
            }
        }, 50); // Simulate some transmission delay
    }, []);

    const nodeAConfig = useMemo(() => ({
        logLevel: 'DEBUG' as 'DEBUG', // Changed to DEBUG
        maxIFieldLength: 200, // Example: Node A supports smaller I-fields
        initialXIDParams: { windowSize: 3, extendedSequencing: false } // Node A prefers smaller window
    }), [nodeACallsign]); // Re-memoize if callsign changes

    const nodeBConfig = useMemo(() => ({
        logLevel: 'DEBUG' as 'DEBUG', // Changed to DEBUG
        maxIFieldLength: 256,
        initialXIDParams: { windowSize: 7, extendedSequencing: true } // Node B prefers larger window
    }), [nodeBCallsign]); // Re-memoize if callsign changes

    const nodeA = useAx25Link(nodeACallsign, sendDataToNodeB, nodeAConfig);
    const nodeB = useAx25Link(nodeBCallsign, sendDataToNodeA, nodeBConfig);

    const handleConnect = () => {
        nodeA.connect(targetCallsign);
    };

    const handleDisconnect = () => {
        nodeA.disconnect();
    };

    const handleSendI = () => {
        if (iMessage) {
            const data = new TextEncoder().encode(iMessage);
            const repeaters = uiRepeaters.split(',').map(r => r.trim()).filter(Boolean);
            nodeA.sendIFrame(data, PIDS.NO_LAYER_3, repeaters);
            setIMessage('');
        }
    };

    const handleSendUI = () => {
        if (uiMessage) {
            const data = new TextEncoder().encode(uiMessage);
            const repeaters = uiRepeaters.split(',').map(r => r.trim()).filter(Boolean);
            nodeA.sendUIFrame(uiDest, repeaters, uiPid, data);
            setUiMessage('');
        }
    };

    return (
        <div style={{ display: 'flex', fontFamily: 'monospace', gap: '20px', padding: '20px' }}>
            <div style={{ flex: 1, border: '1px solid #ccc', padding: '10px', borderRadius: '5px' }}>
                <h1>Node A ({nodeACallsign})</h1>
                <p>Status: <strong style={{ color: nodeA.connectionStatus === LinkState.CONNECTED ? 'green' : 'orange' }}>{nodeA.connectionStatus}</strong></p>
                <p>Connected to: {nodeA.connectedPeer || 'None'}</p>
                <p>TX Q: {nodeA.transmitQueueSize} | RX Buf: {nodeA.receiveBufferSize} | K: {nodeA.maxWindowSize}</p>
                <div>
                    <input
                        type="text"
                        placeholder="Target Callsign (e.g., NODEB-1)"
                        value={targetCallsign}
                        onChange={(e) => setTargetCallsign(e.target.value)}
                        style={{ width: 'calc(100% - 100px)', marginRight: '5px' }}
                    />
                    <button onClick={handleConnect} disabled={nodeA.connectionStatus !== LinkState.DISCONNECTED}>Connect</button>
                    <button onClick={handleDisconnect} disabled={nodeA.connectionStatus === LinkState.DISCONNECTED}>Disconnect</button>
                </div>

                <h3>Connected Mode (I-Frame)</h3>
                <div>
                    <textarea
                        placeholder="Message to send via I-Frame..."
                        value={iMessage}
                        onChange={(e) => setIMessage(e.target.value)}
                        rows={3}
                        style={{ width: '100%' }}
                    ></textarea>
                    <input
                        type="text"
                        placeholder="Repeaters (e.g., WIDE1-1,WIDE2-1)"
                        value={uiRepeaters}
                        onChange={(e) => setUiRepeaters(e.target.value)}
                        style={{ width: '100%', marginBottom: '5px' }}
                    />
                    <button onClick={handleSendI} disabled={nodeA.connectionStatus !== LinkState.CONNECTED || !iMessage}>Send I-Frame</button>
                </div>

                <h3>Connectionless Mode (UI-Frame)</h3>
                <div>
                    <input
                        type="text"
                        placeholder="UI Destination (e.g., CQ, APRS)"
                        value={uiDest}
                        onChange={(e) => setUiDest(e.target.value)}
                        style={{ width: '100%', marginBottom: '5px' }}
                    />
                    <select
                        value={uiPid}
                        onChange={(e) => setUiPid(parseInt(e.target.value))}
                        style={{ width: '100%', marginBottom: '5px' }}
                    >
                        {Object.entries(PIDS).map(([name, value]) => (
                            <option key={name} value={value}>
                                {name} (0x{value.toString(16)})
                            </option>
                        ))}
                    </select>
                    <textarea
                        placeholder="UI Message (APRS, Beacon, etc.)..."
                        value={uiMessage}
                        onChange={(e) => setUiMessage(e.target.value)}
                        rows={3}
                        style={{ width: '100%', marginBottom: '5px' }}
                    ></textarea>
                    <input
                        type="text"
                        placeholder="Repeaters (e.g., WIDE1-1,WIDE2-1)"
                        value={uiRepeaters} // Shared for simplicity
                        onChange={(e) => setUiRepeaters(e.target.value)}
                        style={{ width: '100%', marginBottom: '5px' }}
                    />
                    <button onClick={handleSendUI} disabled={!uiMessage}>Send UI Frame</button>
                </div>

                <h3>Logs (Node A)</h3>
                <div style={{ border: '1px solid #eee', height: '300px', overflowY: 'scroll', background: '#f9f9f9', padding: '5px' }}>
                    {nodeA.messages.map(msg => (
                        <p key={msg.id} style={{ margin: '0', color: msg.type === 'error' ? 'red' : (msg.type === 'system' ? 'blue' : (msg.type === 'ui' ? 'purple' : 'inherit')) }}>
                            {msg.text}
                        </p>
                    ))}
                </div>
            </div>

            <div style={{ flex: 1, border: '1px solid #ccc', padding: '10px', borderRadius: '5px' }}>
                <h1>Node B ({nodeBCallsign})</h1>
                <p>Status: <strong style={{ color: nodeB.connectionStatus === LinkState.CONNECTED ? 'green' : 'orange' }}>{nodeB.connectionStatus}</strong></p>
                <p>Connected to: {nodeB.connectedPeer || 'None'}</p>
                <p>TX Q: {nodeB.transmitQueueSize} | RX Buf: {nodeB.receiveBufferSize} | K: {nodeB.maxWindowSize}</p>
                 <div style={{ height: '50px' }}> {/* Placeholder for controls */} </div>
                 <h3>Logs (Node B)</h3>
                <div style={{ border: '1px solid #eee', height: '300px', overflowY: 'scroll', background: '#f9f9f9', padding: '5px' }}>
                    {nodeB.messages.map(msg => (
                        <p key={msg.id} style={{ margin: '0', color: msg.type === 'error' ? 'red' : (msg.type === 'system' ? 'blue' : (msg.type === 'ui' ? 'purple' : 'inherit')) }}>
                            {msg.text}
                        </p>
                    ))}
                </div>
            </div>
            <div style={{position:'absolute', top: '10px', right: '10px', display: 'flex', flexDirection: 'column'}}>
                <label>Node A Log Level:</label>
                <select onChange={(e) => nodeA.setLogLevel(e.target.value as any)} value={Logger.getInstance().logLevel}>
                    <option value="DEBUG">DEBUG</option>
                    <option value="INFO">INFO</option>
                    <option value="WARN">WARN</option>
                    <option value="ERROR">ERROR</option>
                </select>
                <label>Node B Log Level:</label>
                <select onChange={(e) => nodeB.setLogLevel(e.target.value as any)} value={Logger.getInstance().logLevel}>
                    <option value="DEBUG">DEBUG</option>
                    <option value="INFO">INFO</option>
                    <option value="WARN">WARN</option>
                    <option value="ERROR">ERROR</option>
                </select>
            </div>
        </div>
    );
}

export default App;
